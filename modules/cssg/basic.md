---
layout: default
title: CSS-o-Gram
description: Начало работы

context: inner-page cssg
---

CSSG описывает конструкцию сущности привычным каскадом CSS классов.
Наименование классов происходит в соответствии с принятыми в компании стандартами.
Сторонние проектные классы указываются рядом с основными.
Вспомогательные (косметические) классы как правило не указываются, за исключением особенных случаев (рассматриваются во [второй части]({{ site.baseurl }}/modules/cssg/advanced.html)).

Далее в документации в качестве примера рассматривается вымышленная сущность "post".
Предположим, что это пост в блоге или любая другая запись, у которой есть шапка, тело, футер и прочие элементы.

## Ваша первая CSSG

Предположим, HTML выглядит примерно так:

{% highlight html %}
<div class="post">
	<div class="post_h">
		<div class="post_h_name">Заголовок</div>
	</div>
	<div class="post_b">
		Контент
	</div>
	<div class="post_f">
		Дополнительные сведения
	</div>
</div>
{% endhighlight %}

CSS примерно так:

{% highlight css %}
.post {
	font-size: 14px;
}

.post_h {
	font-weight: bold;
}

и т.д.
{% endhighlight %}

CSSG иллюстрирует структуру HTML в терминологии CSS и располагается в документе _до_ правил:

{% highlight css %}
/*

    post
        post_h
            post_h_name
            post_h_date

        post_b
        	...

        post_f

*/

.post {
	font-size: 14px;
}
{% endhighlight %}

Если вы работали с HAML или имеете представление о его синтаксисе, конструкция более чем привычна.
По умолчанию все элементы конструкии не имеют определенного DOM-представления, т.е. класс первичнее тэга.
Когда необходимо подчеркнуть связь конкретного тэга с классом, используется привычная запись zen-coding:

{% highlight css %}
/*

    post
        post_h
            post_h_name
            i.post_h_date

*/
{% endhighlight %}

Несколько правил:
> потомки элементов отбиваются табами
>
> соседние элементы разделяютс дополнительной строкой в случае наличия потомков
>
> конструкция CSSG для удобства прочтения не должна превышать высоту экрана


## Ключевой контент

Ключевой контент обозначается троеточием - ..., прочий контент игнорируется.
Троеточие подразумевает что вложенность отсутствует, или она не имеет отношения к описываемой структуре.
Пример некорректной CSSG:

{% highlight css %}
/*

    post
        post_h
            post_h_name
            	...
            post_h_date
            	...

        post_b
        	...

        post_f
        	...

*/
{% endhighlight %}

Ключевой контент может располагаться рядом с другой важной частью структуры:

{% highlight css %}
/*

    post
        post_h
            post_h_name
            post_h_date

        post_b
        	...
			post_b_author

        post_f

*/
{% endhighlight %}

Сторонняя сущность, связанная с проектом, обозначается фигурными скобками.
Контент, дополненный сторонней сущностью обозначается рядом троеточием.

{% highlight css %}
/*

    post
        post_h
            {date}
        post_b
            post_cnt
                {... article}

*/
{% endhighlight %}

## Ссылки

В случае громоздкой конструкции удобнее в начале CSS описать скелет конструкции со ссылками на составные части по ходу документа.

{% highlight css %}
>> начало CSS

/*

    post
        #header
        #body
        #aux

*/

>> продолжение CSS

/* #header

    post_h
        post_h_name

*/
{% endhighlight %}

> ссылка на составную часть конструкции обозначается через привычный символ - #

## Модификаторы и проектные классы

Наш HTML меняется - в зависимости от контекста или сам по себе. Модификаторы в CSS позволяют видоизменять сущность.
Модификатор представляет из себя класс типа **.post\_\_new** или **.\_\_compact**, который указывается рядом с основным классом.
Проектный класс (микс-ин) позволяет переиспользовать сущность и указывается самостоятельно или отдельно от основного класса, например - **.post-featured**.

В CSSG возможные модификаторы описываются справа на одном уровне (вне зависимости от уровня вложенности) с целевым классом.
Расстояние выбирается произвольно, исходя из величины диаграммы и удобства прочтения.
Если предполагается возможность проектного заимствования сущности (микс-ина), указываем это _перед_ списком модификаторов.

{% highlight css %}
/*

    post                        -project __new __featured
        post_h
        post_b
            post_b              __compact

*/
{% endhighlight %}

> перечисление модификаторов в таком виде указывает на _возможность_ их одновременного присутствия, без дополнительной логики
>
> подробнее о модификаторах во [второй части]({{ site.baseurl }}/modules/cssg/advanced.html)

## Опциональные части

Если в сущности присутствуют части, которые могу отсутствовать (не обязательные для данной сущности), заключаем их в квадратные скобки.
Если класс один, скобки на этой же строке, в противном случае переносим для удобства прочтения.

{% highlight css %}
/*

    post
        [post_teaser]
        post_h
        post_b
            [
            post_b_top
                post_b_top_tx
            ]

*/
{% endhighlight %}

Если опциональная часть является оберткой, используем следующий синтаксис:

{% highlight css %}
/*

    [post_w]
        post
            post_h
            post_b
            	[post_b_cnt]
            		[post_b_tx]
            			...
            		[/post_b_tx]
        		[/post_b_cnt]
    [/post_w]

*/
{% endhighlight %}

> синтаксис переносов и пробелов в данном случае не является догмой. Здесь на первом месте выступает удобство прочтения и чистота кода
>
> однако при работе в коллективе необходимо выбрать единый синтаксис, одинаковый для всех членов команды

## Неизменяемые блоки

Как правило в крупном проекте или фрэймворке существуют конструкции, которые остаются неизменными вне зависимости от контекста.
Пример таких конструкций - кнопка, простая форма, виджет социальных сетей и т.д.

Когда нельзя их игнорировать или наоборот - _необходимо_ проиллютрировать их наличие применяется следующий синтаксис:

{% highlight css %}
/*

    post
        post_h
        post_b
        post_f
            post_f_ac
                <social>

*/
{% endhighlight %}

> важно составить и периодически дополнять список неизменяемых, переиспользуемых блоков
>
> в большой команде разработчиков список должен быть один